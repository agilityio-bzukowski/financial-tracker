# Frontend Architecture Guide

This document describes the structure, conventions, and design decisions of the frontend codebase so that the pattern can be replicated consistently when adding new features.

---

## Stack

| Concern | Library |
|---|---|
| Runtime | React 19 |
| Language | TypeScript 5 |
| Build tool | Vite |
| Package manager | pnpm |
| Routing | TanStack Router (file-based) |
| Server state | TanStack Query |
| Styling | Tailwind CSS v4 |
| Component primitives | Radix UI (via ShadCN) |
| Icons | Lucide React |
| Variant styling | class-variance-authority + clsx + tailwind-merge |

---

## Directory Layout

```
frontend/src/
├── routes/                    # TanStack Router file-based routes
│   ├── __root.tsx             # Root layout: providers, shell
│   ├── index.tsx
│   └── accounts/
│       ├── index.tsx
│       └── $accountId.tsx
├── features/                  # Feature-scoped modules (one dir per resource)
│   └── accounts/
│       ├── api.ts             # Raw fetch functions (no hooks)
│       ├── queries.ts         # TanStack Query hooks (useQuery, useMutation)
│       ├── AccountList.tsx    # Feature components
│       └── AccountForm.tsx
├── components/
│   ├── ui/                    # ShadCN-generated primitives — never hand-edit
│   └── AppShell.tsx           # Shared composite components
├── lib/
│   ├── api-client.ts          # Base HTTP client (fetch wrapper)
│   └── utils.ts               # cn() helper
└── types/
    └── api.ts                 # Shared TypeScript types (mirrors backend responses)
```

There is one `features/<resource>/` directory per backend resource. When adding a new resource (`transactions`, for example), you create:

- `features/transactions/api.ts`
- `features/transactions/queries.ts`
- `features/transactions/TransactionList.tsx` (and other feature components)
- Types added to `types/api.ts`
- A route file in `routes/` if a dedicated page is needed

---

## Layer Responsibilities

### 1. `routes/` — Pages and Layouts

Routes are thin. They:
- Declare the URL structure via the filename (`$accountId.tsx` → `/accounts/:accountId`)
- Read route params and search params via TanStack Router hooks
- Render one or more feature components
- Do **not** contain data-fetching logic or business UI

The root route (`__root.tsx`) provides global providers: `QueryClientProvider`, the app shell, and devtools.

### 2. `features/<resource>/api.ts` — HTTP Functions

Raw, typed `fetch` calls. No React, no hooks. Each function:
- Calls `apiClient` from `lib/api-client.ts`
- Accepts typed arguments
- Returns a typed promise
- Throws on non-2xx responses (handled by `apiClient`)

### 3. `features/<resource>/queries.ts` — TanStack Query Hooks

All `useQuery` and `useMutation` hooks for a resource live here. This file:
- Defines a **query key factory** for the resource
- Wraps `api.ts` functions in `useQuery` / `useMutation`
- Handles cache invalidation in `onSuccess` callbacks
- Is the **only** place components interact with server state

### 4. `components/ui/` — ShadCN Primitives

Auto-generated by the ShadCN CLI. **Never hand-edit these files.** Re-run the CLI to update or add components:

```bash
pnpm dlx shadcn@latest add <component>
```

### 5. `components/` — Shared Composites

Shared UI built on top of `components/ui/`. These are feature-agnostic (e.g. `PageHeader`, `DataTable`, `ConfirmDialog`). Feature-specific components live in `features/` instead.

### 6. `lib/api-client.ts` — HTTP Client

A thin wrapper around `fetch` that:
- Prepends the base URL
- Sets `Content-Type: application/json`
- Throws a typed `ApiError` on non-2xx responses

All `api.ts` files import from here. Never call `fetch` directly in feature code.

### 7. `types/api.ts` — Shared Types

TypeScript interfaces mirroring backend Pydantic response schemas. These are the contract between frontend and backend. Keep them in sync with `backend/app/models/`.

---

## Data Flow

```
URL / User Action
    → TanStack Router route (routes/*.tsx)
        → Feature component (features/<resource>/*.tsx)
            → TanStack Query hook (features/<resource>/queries.ts)
                → API function (features/<resource>/api.ts)
                    → lib/api-client.ts
                        → Backend HTTP API
            ← Query returns { data, isPending, isError }
        ← Component renders data via ShadCN primitives (components/ui/)
```

---

## State Management

| State type | Where it lives |
|---|---|
| Server state (remote data) | TanStack Query cache |
| URL / navigation state | TanStack Router search params |
| Ephemeral UI state | `useState` / `useReducer` inside the component |
| Shared client-only state | React context (only if genuinely global) |

Avoid adding a global state library. Most state in a data-driven app belongs either in the server cache (TanStack Query) or in the URL (TanStack Router).

---

## TanStack Query Best Practices

### Cache lifetime: `staleTime` vs `gcTime`

| Option | What it controls | Default |
|---|---|---|
| `staleTime` | How long cached data is considered fresh (no background refetch on mount) | `0` |
| `gcTime` | How long **inactive** query data stays in memory before being garbage-collected | `5 min` |

Set a non-zero `staleTime` on the `QueryClient` to avoid refetching identical data on every component mount. The project default is **1 minute**. Override per-query for resources that change more (or less) frequently.

### Query key factories

Always define query keys as a factory object co-located with the hooks file (`queries.ts`). Never hardcode raw string arrays for `invalidateQueries` or `setQueryData` calls — reference the factory instead.

```ts
export const accountKeys = {
  all:    ["accounts"] as const,
  lists:  () => [...accountKeys.all, "list"] as const,
  detail: (id: string) => [...accountKeys.all, "detail", id] as const,
}
```

Hierarchical keys make it trivial to invalidate a whole resource (`accountKeys.all`) or just the list (`accountKeys.lists()`).

### Dependent queries

Use the `enabled` option to prevent a query from running until its prerequisite data exists. Never chain `.then()` inside `queryFn` to fan out into additional queries.

```ts
const { data: user }     = useQuery({ queryKey: userKeys.detail(id), queryFn: ... })
const { data: projects } = useQuery({
  queryKey: projectKeys.byUser(user?.id ?? ""),
  queryFn:  () => projectsApi.byUser(user!.id),
  enabled:  !!user?.id,
})
```

### Data selection / transformation

Use the `select` option to derive or filter data from the cache without altering what is stored. Wrap the selector in `useCallback` to keep it stable across renders.

```ts
const { data: count } = useQuery({
  queryKey: accountKeys.lists(),
  queryFn:  accountsApi.list,
  select:   useCallback((accounts) => accounts.length, []),
})
```

### Optimistic updates

For mutations where immediate feedback matters, apply the change to the cache in `onMutate`, then roll back in `onError` and invalidate in `onSettled`. See `CODING_PATTERNS.md` section 10 for a full example.

### Prefetching

Call `queryClient.prefetchQuery` (e.g. on hover or on route loader) to populate the cache before a component mounts. Prefetched data respects `staleTime`; if already fresh it is not re-fetched.

### Suspense mode

`useSuspenseQuery` guarantees `data` is defined at render time (no `isPending` check needed). Pair it with `<Suspense>` for the loading fallback and `QueryErrorResetBoundary` + `<ErrorBoundary>` for error recovery. Prefer this pattern for leaf data-display components where the simpler mental model outweighs the extra boundary boilerplate.

### `initialData` and `placeholderData`

Use these options to improve perceived performance when you already have partial data available:

| Option | Behaviour | Cache effect |
|---|---|---|
| `initialData` | Treated as real data; respects `staleTime` | Written to the cache |
| `placeholderData` | Shown while the real fetch is in flight | Never written to cache |

Prefer `placeholderData` when you want to display a previous result (e.g. paginated tables: `placeholderData: keepPreviousData`) without polluting the cache. Use `initialData` only when you can guarantee the data is already fresh (e.g. seeded from SSR).

### Key principles

- **Feature-first, not type-first** — group files by domain (`accounts/`, `transactions/`) not by role (`hooks/`, `services/`). One `features/<resource>/` directory per backend resource scales cleanly.
- **Never hardcode query keys** — always use the `*Keys` factory defined in `queries.ts`. Hardcoded string arrays cause silent cache-invalidation bugs.
- **Fetch functions are plain JS** — `api.ts` files contain no React or hooks, making them independently testable and reusable in non-component contexts.
- **One `QueryClient` instance** — created once in `routes/__root.tsx`, never re-created inside a component or hook.
- **`invalidateQueries` over `refetchQueries`** — invalidation marks data stale and only triggers a real network request for currently-mounted queries; `refetchQueries` always fires immediately regardless of active observers.
- **`refetchOnWindowFocus`** — defaults to `true` which is useful for long-lived dashboards but can be noisy in forms. Disable it per-query or globally in `QueryClient` defaults when the behaviour is unwanted.

---

## Adding a New Resource — Checklist

1. **`types/api.ts`** — Add TypeScript interfaces mirroring `*Response` shapes from the backend.
2. **`features/<resource>/api.ts`** — Add typed `fetch` functions for each endpoint.
3. **`features/<resource>/queries.ts`** — Add query key factory, `useQuery` hooks, and `useMutation` hooks.
4. **`features/<resource>/<Component>.tsx`** — Build feature UI using ShadCN components and query hooks.
5. **`routes/`** — Add a route file if the resource needs a dedicated page.
6. **`components/ui/`** — Run `pnpm dlx shadcn@latest add <component>` if new ShadCN primitives are needed.
